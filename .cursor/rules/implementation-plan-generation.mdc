---
alwaysApply: false
description: Implementation plan generation methodology and structured planning framework
---
# Implementation Plan Generation

## Core Principles

### Plan Generation Standards
You WILL generate implementation plans that are fully executable by AI agents or humans with these requirements:

- **Deterministic Language**: Use zero ambiguity in all descriptions
- **Self-Contained Plans**: No external dependencies for understanding
- **Machine-Parseable**: Structure for automated parsing and execution
- **Atomic Phases**: Discrete, independently processable phases
- **Measurable Criteria**: Clear completion criteria for each phase
- **Parallel Execution**: Tasks executable in parallel unless dependencies specified

### AI-Optimized Implementation
You WILL follow these standards for AI execution:

- **Explicit Language**: Zero interpretation required - be completely unambiguous
- **Structured Formats**: Use tables, lists, and structured data for parsing
- **Specific References**: Include exact file paths, function names, line numbers
- **Complete Context**: Provide all necessary information within each task
- **Standardized Identifiers**: Use REQ-, TASK-, GOAL- prefixes consistently
- **Validation Criteria**: Include automatically verifiable completion checks

## Plan Structure Requirements

### Mandatory Template Structure
You WILL strictly adhere to this template structure for all implementation plans:

```markdown
---
goal: [Concise Title Describing Implementation Goal]
version: [Optional: e.g., 1.0, Date]
date_created: [YYYY-MM-DD]
last_updated: [Optional: YYYY-MM-DD]
owner: [Optional: Team/Individual responsible]
status: 'Completed'|'In progress'|'Planned'|'Deprecated'|'On Hold'
tags: [Optional: feature, upgrade, chore, architecture, migration, bug]
---

# Introduction
![Status: ](https://img.shields.io/badge/status-Completed-brightgreen)
[A short concise introduction to the plan and goal]

## 1. Requirements & Constraints
[Explicitly list all requirements & constraints]
- **REQ-001**: Requirement 1 description
- **SEC-001**: Security requirement 1
- **[3 LETTERS]-001**: Other requirement 1
- **CON-001**: Constraint 1
- **GUD-001**: Guideline 1
- **PAT-001**: Pattern to follow 1

## 2. Implementation Steps
### Implementation Phase 1 - GOAL-001: [Phase goal description]
| Task | Description | Completed | Date |
|------|-------------|-----------|------|
| TASK-001 | Task description | âœ… | 2025-04-25 |
| TASK-002 | Task description | | |

## 3. Alternatives
[Alternative approaches considered]
- **ALT-001**: Alternative approach 1
- **ALT-002**: Alternative approach 2

## 4. Dependencies
[Dependencies that need addressing]
- **DEP-001**: Dependency 1
- **DEP-002**: Dependency 2

## 5. Files
[Files affected by implementation]
- **FILE-001**: Description of file 1
- **FILE-002**: Description of file 2

## 6. Testing
[Tests needed for verification]
- **TEST-001**: Description of test 1
- **TEST-002**: Description of test 2

## 7. Risks & Assumptions
[Risks and assumptions related to implementation]
- **RISK-001**: Risk 1
- **ASSUMPTION-001**: Assumption 1

## 8. Related Specifications / Further Reading
[Link to related spec 1]
[Link to relevant external documentation]
```

### Template Validation Rules
You WILL ensure compliance with these validation rules:

- **Front Matter**: All fields present and properly formatted
- **Section Headers**: Exact match (case-sensitive) to template
- **Identifier Prefixes**: Follow specified format (REQ-, TASK-, etc.)
- **Table Structure**: All required columns with specific task details
- **No Placeholders**: All template text replaced with actual content

## Plan File Specifications

### File Organization
You WILL save implementation plan files according to these specifications:

- **Directory**: Save in `/plan/` directory
- **Naming Convention**: `[purpose]-[component]-[version].md`
- **Purpose Prefixes**: upgrade, refactor, feature, data, infrastructure, process, architecture, design
- **Examples**:
  - `upgrade-system-command-4.md`
  - `feature-auth-module-1.md`
  - `refactor-translation-service-2.md`
  - `architecture-extension-structure-1.md`

### Version Management
You WILL manage plan versions according to these rules:

- **Version Format**: Use semantic versioning (1.0, 1.1, 2.0) or dates (2025-01-15)
- **Status Tracking**: Update status field to reflect current state
- **Change Documentation**: Use last_updated field for modification tracking
- **Deprecation**: Mark deprecated plans with appropriate status

## Phase Architecture

### Phase Design Principles
You WILL design phases with these characteristics:

- **Atomic Nature**: Each phase independently processable
- **Clear Boundaries**: No cross-phase dependencies unless explicitly declared
- **Measurable Completion**: Specific criteria for phase completion
- **Parallel Execution**: Tasks can run in parallel unless dependencies specified

### Task Specifications
You WILL create tasks with these requirements:

- **Specific File Paths**: Include exact file locations
- **Function Names**: Specify exact function names to modify/create
- **Line Numbers**: Include line numbers where applicable
- **Implementation Details**: Provide complete technical specifications
- **No Interpretation**: Tasks must be executable without human decision-making

### Dependency Management
You WILL handle dependencies explicitly:

- **Intra-Phase Dependencies**: Specify task execution order within phases
- **Inter-Phase Dependencies**: Declare dependencies between phases
- **External Dependencies**: List external libraries, frameworks, services
- **Resource Dependencies**: Specify required tools, permissions, access

## Information Gathering Integration

### Tool Usage for Plan Generation
You WILL integrate available tools to inform plan creation:

**Codebase Exploration**:
- Use `codebase` to examine existing code structure and patterns
- Use `search` to find specific patterns and implementations
- Use `usages` to understand component interactions
- Use `problems` to identify existing issues and constraints

**Test and Quality Analysis**:
- Use `findTestFiles` to understand testing patterns
- Use `searchResults` to analyze code quality and patterns
- Use `problems` to identify potential implementation challenges

**External Research**:
- Use `fetch` to gather latest documentation and standards
- Use `githubRepo` to research similar implementations
- Use `extensions` to understand available tooling

### Research Integration
You WILL integrate research findings into plans:

**Pattern Analysis**:
- Extract common patterns from existing codebase
- Research industry standards and best practices
- Identify successful vs unsuccessful approaches
- Document patterns for consistent application

**Architecture Understanding**:
- Analyze existing system architecture
- Identify integration points and dependencies
- Understand scalability and performance considerations
- Map out component relationships and data flow

**Constraint Identification**:
- Identify technical limitations and requirements
- Analyze resource constraints and dependencies
- Consider timeline and complexity factors
- Document assumptions and prerequisites

## Plan Generation Process

### Phase 1: Requirements Analysis
You WILL start with comprehensive requirements gathering:

1. **Goal Definition**: What exactly needs to be accomplished?
2. **Scope Identification**: What is and isn't included in the plan?
3. **Constraint Analysis**: What limitations affect implementation?
4. **Success Criteria**: How will success be measured?

### Phase 2: Context Building
You WILL explore the existing environment:

1. **Codebase Analysis**: Understand current structure and patterns
2. **Architecture Review**: Analyze system design and components
3. **Dependency Mapping**: Identify required libraries and services
4. **Integration Points**: Find where new code connects to existing systems

### Phase 3: Strategy Development
You WILL create the implementation strategy:

1. **Phase Design**: Break work into atomic, executable phases
2. **Task Specification**: Create detailed, unambiguous tasks
3. **Dependency Management**: Define task and phase relationships
4. **Resource Planning**: Identify required tools and access

### Phase 4: Risk and Alternative Analysis
You WILL consider risks and alternatives:

1. **Risk Identification**: Find potential implementation challenges
2. **Alternative Approaches**: Consider different implementation strategies
3. **Mitigation Planning**: Develop strategies for identified risks
4. **Fallback Options**: Plan for alternative execution paths

### Phase 5: Validation and Review
You WILL validate the plan's completeness:

1. **Task Verification**: Ensure all tasks are executable and specific
2. **Dependency Validation**: Confirm all dependencies are properly declared
3. **Resource Confirmation**: Verify all required resources are available
4. **Success Criteria**: Ensure completion criteria are measurable

## Plan Execution Standards

### Task Execution Requirements
You WILL ensure tasks meet execution standards:

**Technical Specificity**:
- Include exact file paths and line numbers
- Specify function names and class structures
- Provide complete code snippets where needed
- Define configuration values and constants

**Environmental Context**:
- Specify required development environment setup
- Include necessary tool installations
- Document required permissions and access
- Define testing environment requirements

**Validation Methods**:
- Provide automated verification scripts where possible
- Include manual verification steps with clear criteria
- Specify expected outputs and behaviors
- Define success/failure conditions

### Phase Completion Criteria
You WILL define clear phase completion standards:

**Objective Measures**:
- All tasks marked as completed
- Automated tests passing
- Code reviews completed
- Documentation updated

**Subjective Measures**:
- Code quality standards met
- Performance requirements satisfied
- Security requirements fulfilled
- User experience requirements met

**Integration Measures**:
- Successful integration with existing systems
- No breaking changes introduced
- Backward compatibility maintained
- External dependencies satisfied

## Plan Documentation Standards

### Plan Metadata Requirements
You WILL include comprehensive metadata:

**Identification Information**:
- Clear, descriptive goal statement
- Version tracking with semantic versioning
- Creation and modification dates
- Responsible party identification

**Classification Information**:
- Status with color-coded badges
- Relevant tags for categorization
- Complexity and effort estimation
- Priority and urgency indicators

### Content Standards
You WILL maintain high documentation quality:

**Clarity and Precision**:
- Use unambiguous, technical language
- Provide specific examples and references
- Include error conditions and edge cases
- Document assumptions and limitations

**Completeness**:
- Cover all implementation aspects
- Include testing and validation procedures
- Document rollback and recovery procedures
- Provide troubleshooting guidance

**Maintainability**:
- Structure for easy updates and modifications
- Include version history and change tracking
- Provide clear ownership and responsibility
- Enable easy plan evolution and refinement

This implementation plan generation system ensures creation of detailed, executable plans that can be processed by AI agents or humans with minimal interpretation required, leading to consistent and successful implementation outcomes.
